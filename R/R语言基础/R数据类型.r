############################################################################ 向量start ############################################################################

############# 向量的索引从1开始

###### R语言没有指针，向量调用函数后向量的值不会改变（Python中会改变）

### 向量与维数不同的向量运算时短向量能够循环补齐

###### 向量与向量之间的+-*/都是元素与元素的计算，而不是矩阵运算
### 因此判断两个向量是否相等，不能直接用==，可用all(A==B)或identical()函数
> x <- 1:2
> y <- c(1, 2)
> identical(x, y) # 只有两个向量完全一致才是TRUE，这里x的元素是integer型，y是double型
[1] FALSE
> all(x == y)
[1] TRUE # 只要值相等就是TRUE
> typeof(x)
[1] "integer"
> typeof(y)
[1] "double"

## 负数的下标代表把相应元素剔除（原向量并没有改变）
> z <- c(5, 12, 13)
> z[-1]
[1] 12 13
> z[-1: -2]
[1] 13

### seq()函数：创建等差数列向量，可设置起始值、终点值和步长（可以为整数和小数）
> seq(from=12, to=30, by=3)
[1] 12 15 18 21 24 27 30
### 可在for循环中使用seq()，如for(i in seq(x))，避免使用for(i in 1:length(x))时x的长度为0时相当于(1,0)
> x <- c(5, 12, 13)
> seq(x)
[1] 1 2 3
> x <- NULL
> seq(x)
integer(0) # 长度为0的integer向量

# 使用all()和any()判断参数至少有一个或全部是TRUE
> x <- 1:10
> any(x > 8)
[1] TRUE
> all(x > 8)
[1] FALSE

### subset()函数：筛选向量中满足条件的元素，可去掉NA值
> x <- c(6, 1:3, NA, 12)
> x[x > 5]
[1]  6 NA 12
> subset(x, x > 5)
[1]  6 12

##### which()函数：筛选向量中满足条件的元素索引
> x <- c(6, 1:3, NA, 12)
> which(x > 5)
[1] 1 6
### which()函数可用于找出满足条件的元素首次出现的位置
> which(x == 1)[1]
[1] 2

##### grepl()函数:在向量中找到指定模式时返回值True，未找到则返回false。其语法为grepl(pattern, string, ignore.case=FALSE)
> str <- c("GFG", "gfg", "Geek", "Geeks") 
> grepl('GF', str, ignore.case ="True")
[1]  TRUE  TRUE FALSE FALSE

### ifelse()函数：向量化版本的if-then-else函数，相当于java的?:
> x <- 1:10
> ifelse(x %% 2 == 0, 0, 1)
 [1] 1 0 1 0 1 0 1 0 1 0

###### lapply()函数：对多个向量执行相同的函数。对比一个一个执行代码更加简洁，而且速度稍快
> x <- c(1, 0, 1, 1, 0)
> y <- c(0, 1, 0, 0, 1)
> func <- function(v) {
+     return(ifelse(v > 0, 1,- 1))
+ }
> lapply(list(x, y), func)
[[1]]
[1]  1 -1  1  1 -1
[[2]]
[1] -1  1 -1 -1  1

### diff()函数：对向量进行“滞后”运算。默认为滞后一期，可设置滞后期数
> x <- c(1, 0, 1, 1, 0)
> diff(x)
[1] -1  1  0 -1
> diff(x, 3)
[1] 0 0

### sign()函数：根据向量中的数值是正值、零或负值，将其分别转化为1、0、或-1
> x <- c(1, 0, 1, 1, 0)
> sign(diff(x))
[1] -1  1  0 -1

# names()函数：给向量中的元素命名。命名后可通过元素名索引元素
> x <- c(1, 2, 3)
> names(x) <- c("a", "b", "c")
> x
a b c 
1 2 3 

##### 使用sort()函数返回元素从小到大排序后的向量，使用order()显示从小到大的元素索引组成的向量，rank()函数返回每一个元素的秩位
> x <- c(2, 3, 2, 4)
> sort(x)
[1] 1 2 3 4
> order(x)
[1] 3 1 2 4
> rank(x)
[1] 1.5 3.0 1.5 4.0

############################################################################## 向量end #############################################################################

############################################################################ 字符串start ###########################################################################

##### 获取字符长度：nchar()函数、stringr:str_length()函数
> nchar("abc de/n")
[1] 8
> nchar(NULL) # 用在非字符串上可能会得到不可预料的结果，要想得到一致的结果，可使用CRAN上的stringr包
integer(0)
> nchar(NA)
[1] NA
> str_length(c("a", NULL, NA))
[1]  1 NA

##### 拼接字符串：paste()函数、stringr:str_c()函数
> paste("abc", "de") # 默认分隔符为空格
[1] "abc de"
> paste("abc", "de", sep = "") # 不需要分隔符
[1] "abcde"
> paste("prefix-", c("a", "b", "c"), "-suffix") # 可向量化，stringr:str_c()函数效果一样
[1] "prefix- a -suffix" "prefix- b -suffix" "prefix- c -suffix"
> paste0("abc", "de")
[1] "abcde"
> str_c("abc", "de")
[1] "abcde"
> str_c("abc", "de", sep = ",")
[1] "abc,de"

##### 截取字符串：subst()函数、stringr:str_sub()函数
> substr("abcde", 2, 4)
[1] "bcd"
> str_sub(c("Apple", "Banana", "Pear"), 1, 3) # 可向量化
[1] "App" "Ban" "Pea"
> str_sub(c("Apple", "Banana", "Pear"), 2) # stringr:str_sub()函数可缺省终止位置，substr不行
[1] "pple"  "anana" "ear" 
> x <- "Apple"
> str_sub(x, 1) <- str_to_lower(str_sub(x, 1)) # 还可以使用str_sub()函数的赋值形式来修改字符串
> x
[1] "apple"

##### 按分隔符分割字符串：strsplit()函数
> strsplit("2022-11-5", split = "-")
[[1]]
[1] "2022" "11"   "5" 
# 注意按元字符划分时，需要加上fixed=T参数，否则需使用转移后的字符作为分隔符
> strsplit("CRC_hg19_MHB.bed", ".")
[[1]]
 [1] "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" ""
> strsplit("CRC_hg19_MHB.bed", ".", fixed = T)
[[1]]
[1] "CRC_hg19_MHB" "bed"         
> strsplit("CRC_hg19_MHB.bed", "\\.")
[[1]]
[1] "CRC_hg19_MHB" "bed" 

##### 在字符串中寻找子字符串所在的第一个位置：regexpr()函数
> regexpr("bc", "abced")
[1] 2
attr(,"match.length")
[1] 2
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE
##### 找出子字符串在字符串中的所有位置：gregexpr()函数
> gregexpr("bc", "abcedcbcbca")
[[1]]
[1] 2 7 9
attr(,"match.length")
[1] 2 2 2
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

## 在字符串向量中搜索子字符串：grep(pattern, strList)函数
> s <- c("abc", "bcd", "cde")
> grep("d", s) # 返回存在子字符串的字符串在向量中的位置
[1] 2 3

### 格式化输出：sprintf()函数
> sprintf("The result is: %d", 1)
[1] "The result is: 1"
# 可用于批量创建多个文件
> for(i in 1:5) {
+ fname <- sprintf("file%d.pdf", i)
+ pdf(fname)
+ }
# 注意%d是整型、%f和%g是浮点型，但%f含有6位小数
> sprintf("%f", 1.2)
[1] "1.200000"
> sprintf("%g", 1.2)
[1] "1.2"

############################################################################# 字符串end ############################################################################

############################################################################# 列表start ############################################################################

## 从技术上讲，列表就是向量。但向量是最小的，不可再分的，列表是递归型向量，列表的组件可以是列表

###### 列表基本操作
### 创建列表
> x <- list("Joe", 5000, T) # 不指定组件标签
> x
[[1]]
[1] "Joe"
[[2]]
[1] 5000
[[3]]
[1] TRUE
> x <- list(name = "Joe", salary = 5000, union = T) # 指定组件标签
> x
$name
[1] "Joe"
$salary
[1] 5000
$union
### 添加新组件，也可以使用索引添加新组件
> x$address <- "home"
### 删除组件，直接把其值设置为NULL即可
> x$union <- NULL
### 获取列表长度
> length(x)
[1] 3


## 获取列表组件值
[1] TRUE
> x$name # 根据标签获取组件值，也可以用x[["name"]]或x[[2]]
[1] "Joe"
> x$sal # 可以使用标签的前缀，一般都能识别
[1] 5000

## 获取子列表：使用[]获取子列表，使用[[]]获取的是列表的组件值（一次只能获取一个，不能用:）
> x[1:2]
$name
[1] "Joe"
$salary
[1] 5000

# names()函数：获取列表标签集
> names(x)
[1] "name"    "salary"  "address"
> xun <- unname(x) # 去掉列表标签值

## unlist()函数：获取列表的值，返回的是一个向量
> unlist(x)
   name  salary address 
  "Joe"  "5000"  "home" 
> unlist(x)[1]
 name 
"Joe" 

##### 在列表上使用apply系列函数（包括lapply()和sapply()函数）
> x = list(1:3, 2:5)
> lapply(x, median) # 分别对列表的两个向量求中位数，返回一个列表
[[1]]
[1] 2
[[2]]
[1] 3.5
> sapply(x, median) # 返回一个矩阵或向量
[1] 2.0 3.5

############################################################################# 列表end #############################################################################

########################################################################## 数据框start ############################################################################

## 创建数据框
> x <- c(2, 3, 1, 4)
> y <- c("a", "b")
> d <- data.frame(x, y)
> d
  x y
1 2 a
2 3 b
3 1 a
4 4 b

# 各种矩阵操作都可运用于数据框中

### apply类型函数也可运用于数据框上
> d
  x y
1 2 a
2 3 b
3 1 a
4 4 b
> lapply(d, sort) # 将sort函数应用于每一列，返回一个列表
$x
[1] 1 2 3 4
$y
[1] "a" "a" "b" "b"

#### complete.cases()函数：判断是否存在至少一个缺失值
d[complete.cases(d), ] # 删除含有NA值的行

### 可使用rbind()和cbind()函数向数据框中添加新行/列
> d
  y x
1 a 2
2 b 3
> rbind(d, list("c", 4)) # 添加一行
  y x
1 a 2
2 b 3
3 c 4
> cbind(d, d$x - 1) # 使用原列计算生成新列
  y x d$x - 1
1 a 2       1
2 b 3       2
> d$subOne <- d$x - 1 # 给新列命名
> d
  y x subOne
1 a 2      1
2 b 3      2

##### merge()函数：合并两个数据框
merge(d1, d2) # 合并含有一个或多个同名的列的数据框
merge(d1, d2， by.x = "kids", by.y = "names") # by.x和by.y参数标示出两个数据框中含有相同信息但名称不同的列（最后以x的名称为准）

########################################################################### 数据框end #############################################################################


########################################################################### 矩阵start #############################################################################

## matrix()函数：创建矩阵
> x <- matrix(c(1, 2, 3, 4), nrow = 2, ncol = 2)
> x
     [,1] [,2]
[1,]    1    3
[2,]    2    4

### 一般矩阵运算
> x * 2 # 矩阵数量乘法
     [,1] [,2]
[1,]    2    6
[2,]    4    8
> x + 2 # 矩阵加法
     [,1] [,2]
[1,]    3    5
[2,]    4    6
> x %*% x # 矩阵相乘
     [,1] [,2]
[1,]    7   15
[2,]   10   22

## 矩阵索引
x[2:3, ] # 筛选第2/3行
x[, 2:3] # 筛选第2/3列

##### 矩阵元素筛选
x[x[, 2] >= 3, ] # 获取第二列元素大于3的行
x[x[, 1] > 1 & x[, 2] > 5, ] # 获取第一列大于1且第二列大于5的行（这里是用&而不是&&【仅用于if语句】）

## 矩阵也是向量，因此向量的运算也适用于矩阵，如which()
> x
     [,1] [,2]
[1,]    1    3
[2,]    2    4
> which(x > 2)
[1] 3 4

### row()和col()函数：返回一个由整数组成的矩阵，每个整数代表矩阵对应元素的行/列号
> row(x)
     [,1] [,2]
[1,]    1    1
[2,]    2    2
> col(x)
     [,1] [,2]
[1,]    1    2
[2,]    1    2
> row(x) == col(x) # 可使用这两个函数生成对角、上三角、下三角矩阵
      [,1]  [,2]
[1,]  TRUE FALSE
[2,] FALSE  TRUE

######### dim()函数：返回矩阵的行数和列数
> dim(x)
[1] 2 2
# 其实row和col函数都是对dim函数的一个封装，可直接输入对象名称就可以看见其内容
> nrow
function (x) 
dim(x)[1L]
<bytecode: 0x00000214f838d490>
<environment: namespace:base>

########## apply()函数：一般形式为apply(m, dimcode, f, fargs)
########## 其中m是一个矩阵，dimcode是维度编号，若为1/2代表对行/列应用函数，f是应用在行/列上的函数，fargs是f的可选参数集
apply(x, 2, mean) # 计算每一列的平均值（也可以直接使用colMeans()函数）
## apply函数不能使程序的运行速度加快，其优点是使程序更紧凑，更易阅读和修改，并且避免产生使用循环语句时可能带来的bug。
## 此外，并行运算是R目前发展方向之一，apply这类函数变得越来越重要，如snow包的clusterApply函数能够把子矩阵的数据分配到多个网络节点上，在每个网络节点调用特定的函数，达到并行计算的目的

#### 增加或删除矩阵的行/列
> one <- c(1, 1)
> x
     [,1] [,2]
[1,]    1    3
[2,]    2    4
> cbind(one, x) # 按列合并两个向量
     one    
[1,]   1 1 3
[2,]   1 2 4
> rbind(one, x) # 按行合并两个向量
    [,1] [,2]
one    1    1
       1    3
       2    4

### 避免矩阵意外降维：有时候提取矩阵的一部分时，若只有一行，则提取出来的对象会变成向量而不是矩阵
> x
     [,1] [,2]
[1,]    1    3
[2,]    2    4
> r <- x[2, ]
> typeof(r)
> r <- x[2, , drop=FALSE]
> attributes(r)
NULL
> attributes(r)
$dim
[1] 1 2
## 也可以使用as.matrix()函数显式将向量转化为矩阵（注意此函数是按列排序的，有必要需进行转置）
> r <- as.matrix(x[2, ])
> r
     [,1]
[1,]    2
[2,]    4

############################################################################ 矩阵end ##############################################################################

####################################################################### 因子和表start #############################################################################

## R中的因子可看做一个附加了更多信息的向量，额外的信息包括向量中不同值的记录，称为“水平”
> x <- c(2, 3, 3, 1, 5)
> f <- factor(x)
> f
[1] 2 3 3 1 5
Levels: 1 2 3 5

### split()函数：基本形式是split(x, f)，x和f与apply()函数相同。可将向量分割成组，输出一个列表
> xf <- c("O", "J", "J", "J", "J")
> split(1:5, xf) # 可用来获取不同元素的下标集
$J
[1] 2 3 4 5
$O
[1] 1

### tapply()函数：典型用法为tapply(x, f, g)，其中x为向量，f为因子或因子列表，g为函数
### tapply执行的操作是：将x分组，每组对应一个因子水平，得到x的子向量，然后对这些子向量应用函数g
> x <- c(2, 3, 3, 1, 5)
> xf <- c("O", "J", "J", "J", "J")
> tapply(x, xf, mean)
J O 
3 2 
### 若具有多重因子，每个因子将产生一系列的组，假设一个数据集包含性别、年龄和收入，f因子可以是性别+年龄是否大于25

### by()函数：与tapply()函数作用相同，第一个参数不一定是向量，还可以是矩阵或数据框

### aggregate()函数：对分组中的每一个变量调用tapply()函数

### cut(函数：格式为cut(x, b, lables = FALSE)，其中x为数据向量，b为一组区间（半开半闭区间(a,b]），函数确定x中的每个元素落入那个区间
> x
[1] 2 3 3 1 5
> region <- seq(from = 1, to = 5, by = 2)
> cut(x, region, labels = F)
[1]  1  1  1 NA  2

### table()函数：对向量、列表、数据框等进行分组，可一维、二维或多维
> x
[1] 2 3 3 1 5
> table(x)
x
1 2 3 5 
1 1 2 1 
> d
  x y
1 2 a
2 3 b
3 1 a
4 4 b
> table(d)
   y
x   a b
  1 1 0
  2 1 0
  3 0 1
  4 0 1

######################################################################## 因子和表end ##############################################################################



######################################################################## 其他数据类型start ########################################################################

########## 使用lubridate处理日期和时间（nycflights13包作为练习数据）
##### 创建日期或时间
> today()
[1] "2022-12-02"
> now()
[1] "2022-12-02 15:12:45 CST"
##### 通过字符串创建日期或时间：根据年（y）、月（m）和日（d）在日期数据中的顺序，组成能够解析日期的lubridate函数名称。创建日期时间型数据，可以在后面加一个下划线，以及h、m和s之中的一个或多个字母
> ymd("2022-12-02")
[1] "2022-12-02"
> dmy("02/12/2022")
[1] "2022-12-02"
> dmy("12-02/2022")
[1] "2022-02-12"
> ymd("20221202")
[1] "2022-12-02"
> ymd_hms("2017-01-31 20:11:59")
[1] "2017-01-31 20:11:59 UTC"
> mdy_hm("01/31/2017 08:01")
[1] "2017-01-31 08:01:00 UTC"
##### 通过各个成分创建日期或时间：make_date()函数创建日期，make_datetime()函数创建日期时间
> flights %>% select(year, month, day, hour, minute) %>% mutate(departure = make_datetime(year, month, day, hour, minute))
# A tibble: 336,776 × 6
    year month   day  hour minute departure          
   <int> <int> <int> <dbl>  <dbl> <dttm>             
 1  2013     1     1     5     15 2013-01-01 05:15:00
 2  2013     1     1     5     29 2013-01-01 05:29:00
### 获取日期时间成分：year()、month()、mday()（一个月中的第几天）、yday()（一年中的第几天）、wday()（一周中的第几天）、hour()、minute()和second()等函数
### 对于month()和wday()函数，可以设置label = TRUE来返回月份名称和星期数的缩写，还可以设置abbr = FALSE来返回全名
> yday(now())
[1] 336
> month(now(), label = T)
[1] 12月
Levels: 1月 < 2月 < 3月 < 4月 < 5月 < 6月 < 7月 < 8月 < 9月 < 10月 < 11月 < 12月
> wday(now(), label = T)
[1] 周五
Levels: 周日 < 周一 < 周二 < 周三 < 周四 < 周五 < 周六
### 还可以使用每个访问器函数来设置日期时间中的成分，或者通过update()函数同时设置多个成分创建一个新日期时间
> dt = now()
> year(dt) <- 2020
> dt
[1] "2020-12-02 15:51:40 CST"
##### 时间间隔
### 将两个日期相减
> age <- today() - ymd(19971217)
> age
Time difference of 9118 days
### lubridate提供了总是使用秒为单位的另一种计时对象——时期
> as.duration(age)
[1] "787795200s (~24.96 years)"
### lubridate还提供了阶段对象，使用“人工”时间，比如日和月
> now() + days(1)
[1] "2022-12-05 19:22:11 CST"
> now() + months(1) + days(1)
[1] "2023-01-05 19:22:53 CST"

######################################################################### 其他数据类型end #########################################################################

