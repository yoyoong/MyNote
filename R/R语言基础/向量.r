############# 向量的索引从1开始

###### R语言没有指针，向量调用函数后向量的值不会改变（Python中会改变）

### 向量与维数不同的向量运算时短向量能够循环补齐

###### 向量与向量之间的+-*/都是元素与元素的计算，而不是矩阵运算
### 因此判断两个向量是否相等，不能直接用==，可用all(A==B)或identical()函数
> x <- 1:2
> y <- c(1, 2)
> identical(x, y) # 只有两个向量完全一致才是TRUE，这里x的元素是integer型，y是double型
[1] FALSE
> all(x == y)
[1] TRUE # 只要值相等就是TRUE
> typeof(x)
[1] "integer"
> typeof(y)
[1] "double"

## 负数的下标代表把相应元素剔除（原向量并没有改变）
> z <- c(5, 12, 13)
> z[-1]
[1] 12 13
> z[-1: -2]
[1] 13

### seq()函数：创建等差数列向量，可设置起始值、终点值和步长（可以为整数和小数）
> seq(from=12, to=30, by=3)
[1] 12 15 18 21 24 27 30
### 可在for循环中使用seq()，如for(i in seq(x))，避免使用for(i in 1:length(x))时x的长度为0时相当于(1,0)
> x <- c(5, 12, 13)
> seq(x)
[1] 1 2 3
> x <- NULL
> seq(x)
integer(0) # 长度为0的integer向量

# 使用all()和any()判断参数至少有一个或全部是TRUE
> x <- 1:10
> any(x > 8)
[1] TRUE
> all(x > 8)
[1] FALSE

### subset()函数：筛选向量中满足条件的元素，可去掉NA值
> x <- c(6, 1:3, NA, 12)
> x[x > 5]
[1]  6 NA 12
> subset(x, x > 5)
[1]  6 12

##### which()函数：筛选向量中满足条件的元素索引
> x <- c(6, 1:3, NA, 12)
> which(x > 5)
[1] 1 6
### which()函数可用于找出满足条件的元素首次出现的位置
> which(x == 1)[1]
[1] 2

### ifelse()函数：向量化版本的if-then-else函数，相当于java的?:
> x <- 1:10
> ifelse(x %% 2 == 0, 0, 1)
 [1] 1 0 1 0 1 0 1 0 1 0

###### lapply()函数：对多个向量执行相同的函数。对比一个一个执行代码更加简洁，而且速度稍快
> x <- c(1, 0, 1, 1, 0)
> y <- c(0, 1, 0, 0, 1)
> func <- function(v) {
+     return(ifelse(v > 0, 1,- 1))
+ }
> lapply(list(x, y), func)
[[1]]
[1]  1 -1  1  1 -1
[[2]]
[1] -1  1 -1 -1  1

### diff()函数：对向量进行“滞后”运算。默认为滞后一期，可设置滞后期数
> x <- c(1, 0, 1, 1, 0)
> diff(x)
[1] -1  1  0 -1
> diff(x, 3)
[1] 0 0

### sign()函数：根据向量中的数值是正值、零或负值，将其分别转化为1、0、或-1
> x <- c(1, 0, 1, 1, 0)
> sign(diff(x))
[1] -1  1  0 -1

# names()函数：给向量中的元素命名。命名后可通过元素名索引元素
> x <- c(1, 2, 3)
> names(x) <- c("a", "b", "c")
> x
a b c 
1 2 3 


##### 使用sort()函数返回元素从小到大排序后的向量，使用order()显示从小到大的元素索引组成的向量，rank()函数返回每一个元素的秩位
> x <- c(2, 3, 2, 4)
> sort(x)
[1] 1 2 3 4
> order(x)
[1] 3 1 2 4
> rank(x)
[1] 1.5 3.0 1.5 4.0