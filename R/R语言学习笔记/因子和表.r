## R中的因子可看做一个附加了更多信息的向量，额外的信息包括向量中不同值的记录，称为“水平”
> x <- c(2, 3, 3, 1, 5)
> f <- factor(x)
> f
[1] 2 3 3 1 5
Levels: 1 2 3 5

### split()函数：基本形式是split(x, f)，x和f与apply()函数相同。可将向量分割成组，输出一个列表
> xf <- c("O", "J", "J", "J", "J")
> split(1:5, xf) # 可用来获取不同元素的下标集
$J
[1] 2 3 4 5
$O
[1] 1

### tapply()函数：典型用法为tapply(x, f, g)，其中x为向量，f为因子或因子列表，g为函数
### tapply执行的操作是：将x分组，每组对应一个因子水平，得到x的子向量，然后对这些子向量应用函数g
> x <- c(2, 3, 3, 1, 5)
> xf <- c("O", "J", "J", "J", "J")
> tapply(x, xf, mean)
J O 
3 2 
### 若具有多重因子，每个因子将产生一系列的组，假设一个数据集包含性别、年龄和收入，f因子可以是性别+年龄是否大于25

### by()函数：与tapply()函数作用相同，第一个参数不一定是向量，还可以是矩阵或数据框

### aggregate()函数：对分组中的每一个变量调用tapply()函数

### cut(函数：格式为cut(x, b, lables = FALSE)，其中x为数据向量，b为一组区间（半开半闭区间(a,b]），函数确定x中的每个元素落入那个区间
> x
[1] 2 3 3 1 5
> region <- seq(from = 1, to = 5, by = 2)
> cut(x, region, labels = F)
[1]  1  1  1 NA  2

### table()函数：对向量、列表、数据框等进行分组，可一维、二维或多维
> x
[1] 2 3 3 1 5
> table(x)
x
1 2 3 5 
1 1 2 1 
> d
  x y
1 2 a
2 3 b
3 1 a
4 4 b
> table(d)
   y
x   a b
  1 1 0
  2 1 0
  3 0 1
  4 0 1