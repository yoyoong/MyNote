## matrix()函数：创建矩阵
> x <- matrix(c(1, 2, 3, 4), nrow = 2, ncol = 2)
> x
     [,1] [,2]
[1,]    1    3
[2,]    2    4

### 一般矩阵运算
> x * 2 # 矩阵数量乘法
     [,1] [,2]
[1,]    2    6
[2,]    4    8
> x + 2 # 矩阵加法
     [,1] [,2]
[1,]    3    5
[2,]    4    6
> x %*% x # 矩阵相乘
     [,1] [,2]
[1,]    7   15
[2,]   10   22

## 矩阵索引
x[2:3, ] # 筛选第2/3行
x[, 2:3] # 筛选第2/3列

##### 矩阵元素筛选
x[x[, 2] >= 3, ] # 获取第二列元素大于3的行
x[x[, 1] > 1 & x[, 2] > 5, ] # 获取第一列大于1且第二列大于5的行（这里是用&而不是&&【仅用于if语句】）

## 矩阵也是向量，因此向量的运算也适用于矩阵，如which()
> x
     [,1] [,2]
[1,]    1    3
[2,]    2    4
> which(x > 2)
[1] 3 4

### row()和col()函数：返回一个由整数组成的矩阵，每个整数代表矩阵对应元素的行/列号
> row(x)
     [,1] [,2]
[1,]    1    1
[2,]    2    2
> col(x)
     [,1] [,2]
[1,]    1    2
[2,]    1    2
> row(x) == col(x) # 可使用这两个函数生成对角、上三角、下三角矩阵
      [,1]  [,2]
[1,]  TRUE FALSE
[2,] FALSE  TRUE

######### dim()函数：返回矩阵的行数和列数
> dim(x)
[1] 2 2
# 其实row和col函数都是对dim函数的一个封装，可直接输入对象名称就可以看见其内容
> nrow
function (x) 
dim(x)[1L]
<bytecode: 0x00000214f838d490>
<environment: namespace:base>

########## apply()函数：一般形式为apply(m, dimcode, f, fargs)
########## 其中m是一个矩阵，dimcode是维度编号，若为1/2代表对行/列应用函数，f是应用在行/列上的函数，fargs是f的可选参数集
apply(x, 2, mean) # 计算每一列的平均值（也可以直接使用colMeans()函数）
## apply函数不能使程序的运行速度加快，其优点是使程序更紧凑，更易阅读和修改，并且避免产生使用循环语句时可能带来的bug。
## 此外，并行运算是R目前发展方向之一，apply这类函数变得越来越重要，如snow包的clusterApply函数能够把子矩阵的数据分配到多个网络节点上，在每个网络节点调用特定的函数，达到并行计算的目的

#### 增加或删除矩阵的行/列
> one <- c(1, 1)
> x
     [,1] [,2]
[1,]    1    3
[2,]    2    4
> cbind(one, x) # 按列合并两个向量
     one    
[1,]   1 1 3
[2,]   1 2 4
> rbind(one, x) # 按行合并两个向量
    [,1] [,2]
one    1    1
       1    3
       2    4

### 避免矩阵意外降维：有时候提取矩阵的一部分时，若只有一行，则提取出来的对象会变成向量而不是矩阵
> x
     [,1] [,2]
[1,]    1    3
[2,]    2    4
> r <- x[2, ]
> typeof(r)
> r <- x[2, , drop=FALSE]
> attributes(r)
NULL
> attributes(r)
$dim
[1] 1 2
## 也可以使用as.matrix()函数显式将向量转化为矩阵（注意此函数是按列排序的，有必要需进行转置）
> r <- as.matrix(x[2, ])
> r
     [,1]
[1,]    2
[2,]    4